/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2017 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * Msltoe Donut formula
 * @reference
 * http://www.fractalforums.com/new-theories-and-research/
 * low-hanging-dessert-an-escape-time-donut-fractal/msg90171/#msg90171
 */

/* ### This file has been autogenerated. Remove this line, to prevent override. ### */

#ifndef DOUBLE_PRECISION
float4 MsltoeDonutIteration(float4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	float radius2 = fractal->donut.ringThickness;
	float nSect = 2.0f * native_divide(M_PI, fractal->donut.number);
	float fact = fractal->donut.factor;

	float R = native_sqrt(mad(z.x, z.x, z.y * z.y));
	float R2 = fractal->donut.ringRadius - R;
	float t = mad(-radius2, radius2, mad(R2, R2, z.z * z.z));

	float theta = atan2(z.y, z.x);
	float theta2 = nSect * round(native_divide(theta, nSect));

	if (t > 0.03f)
	{
		float c1 = native_cos(theta2);
		float s1 = native_sin(theta2);

		float x1 = mad(c1, z.x, s1 * z.y);
		float y1 = mad(-s1, z.x, c1 * z.y);
		float z1 = z.z;

		x1 = x1 - fractal->donut.ringRadius;

		z.x = fact * x1;
		z.y = fact * z1;
		z.z = fact * y1;
	}
	else
	{
		z /= t;
	}
	aux->color += theta2;
	return z;
}
#else
double4 MsltoeDonutIteration(double4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	double radius2 = fractal->donut.ringThickness;
	double nSect = 2.0 * native_divide(M_PI, fractal->donut.number);
	double fact = fractal->donut.factor;

	double R = native_sqrt(mad(z.x, z.x, z.y * z.y));
	double R2 = fractal->donut.ringRadius - R;
	double t = mad(-radius2, radius2, mad(R2, R2, z.z * z.z));

	double theta = atan2(z.y, z.x);
	double theta2 = nSect * round(native_divide(theta, nSect));

	if (t > 0.03)
	{
		double c1 = native_cos(theta2);
		double s1 = native_sin(theta2);

		double x1 = mad(c1, z.x, s1 * z.y);
		double y1 = mad(-s1, z.x, c1 * z.y);
		double z1 = z.z;

		x1 = x1 - fractal->donut.ringRadius;

		z.x = fact * x1;
		z.y = fact * z1;
		z.z = fact * y1;
	}
	else
	{
		z /= t;
	}
	aux->color += theta2;
	return z;
}
#endif
