/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2017 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * rotation folding plane
 */

/* ### This file has been autogenerated. Remove this line, to prevent override. ### */

#ifndef DOUBLE_PRECISION
float4 TransfRotationFoldingPlaneIteration(
	float4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	float4 zRot;
	// cast vector to array pointer for address taking of components in opencl
	float *zRotP = (float *)&zRot;
	__constant float *colP = (__constant float *)&fractal->mandelbox.color.factor;
	for (int dim = 0; dim < 3; dim++)
	{
		// handle each dimension x, y and z sequentially in pointer var dim
		float *rotDim = (dim == 0) ? &zRotP[0] : ((dim == 1) ? &zRotP[1] : &zRotP[2]);
		__constant float *colorFactor = (dim == 0) ? &colP[0] : ((dim == 1) ? &colP[1] : &colP[2]);

		zRot = Matrix33MulFloat4(fractal->mandelbox.rot[0][dim], z);
		if (*rotDim > fractal->mandelbox.foldingLimit)
		{
			*rotDim = fractal->mandelbox.foldingValue - *rotDim;
			z = Matrix33MulFloat4(fractal->mandelbox.rotinv[0][dim], zRot);
			aux->color += *colorFactor;
		}
		else
		{
			zRot = Matrix33MulFloat4(fractal->mandelbox.rot[1][dim], z);
			if (*rotDim < -fractal->mandelbox.foldingLimit)
			{
				*rotDim = -fractal->mandelbox.foldingValue - *rotDim;
				z = Matrix33MulFloat4(fractal->mandelbox.rotinv[1][dim], zRot);
				aux->color += *colorFactor;
			}
		}
	}
	return z;
}
#else
double4 TransfRotationFoldingPlaneIteration(
	double4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	double4 zRot;
	// cast vector to array pointer for address taking of components in opencl
	double *zRotP = (double *)&zRot;
	__constant double *colP = (__constant double *)&fractal->mandelbox.color.factor;
	for (int dim = 0; dim < 3; dim++)
	{
		// handle each dimension x, y and z sequentially in pointer var dim
		double *rotDim = (dim == 0) ? &zRotP[0] : ((dim == 1) ? &zRotP[1] : &zRotP[2]);
		__constant double *colorFactor = (dim == 0) ? &colP[0] : ((dim == 1) ? &colP[1] : &colP[2]);

		zRot = Matrix33MulFloat4(fractal->mandelbox.rot[0][dim], z);
		if (*rotDim > fractal->mandelbox.foldingLimit)
		{
			*rotDim = fractal->mandelbox.foldingValue - *rotDim;
			z = Matrix33MulFloat4(fractal->mandelbox.rotinv[0][dim], zRot);
			aux->color += *colorFactor;
		}
		else
		{
			zRot = Matrix33MulFloat4(fractal->mandelbox.rot[1][dim], z);
			if (*rotDim < -fractal->mandelbox.foldingLimit)
			{
				*rotDim = -fractal->mandelbox.foldingValue - *rotDim;
				z = Matrix33MulFloat4(fractal->mandelbox.rotinv[1][dim], zRot);
				aux->color += *colorFactor;
			}
		}
	}
	return z;
}
#endif
