/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2017 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * Hybrid Color Trial
 *
 * for folds the aux.color is updated each iteration
 * depending on which slots have formulas that use it
 *
 *
 * bailout may need to be adjusted with some formulas
 */

/* ### This file has been autogenerated. Remove this line, to prevent override. ### */

#include "cl_kernel_include_headers.h"

REAL4 TransfHybridColorIteration(REAL4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	// REAL components = 0.0f;
	REAL R2 = 0.0f;
	REAL auxColor = 0.0f;
	REAL distEst = 0.0f;
	REAL XYZbias = 0.0f;
	REAL planeBias = 0.0f;
	REAL divideByIter = 0.0f;
	REAL radius = 0.0f;
	// REAL factorR = fractal->mandelbox.color.factorR;
	REAL componentMaster = 0.0f;
	REAL lastColorValue = aux->colorHybrid;

	// used to turn off or mix with old hybrid color and orbit traps
	aux->oldHybridFactor *= fractal->foldColor.oldScale1;
	aux->minRFactor = fractal->foldColor.scaleC0; // orbit trap weight

	//	if (aux->i >= fractal->transformCommon.startIterationsT
	//		&& aux->i < fractal->transformCommon.stopIterationsT) // hmmmmmmmmmmmmmm
	{
		// radius
		if (fractal->transformCommon.functionEnabledCyFalse)
		{
			radius = length(z);
			radius = fractal->foldColor.scaleG0 * radius;
		}
		// radius squared components
		if (fractal->transformCommon.functionEnabledRFalse)
		{
			REAL temp0 = 0.0f;
			REAL temp1 = 0.0f;
			REAL4 c = aux->c;
			temp0 = dot(c, c) * fractal->foldColor.scaleA0; // initial R2
			temp1 = dot(z, z) * fractal->foldColor.scaleB0;
			R2 = temp0 + temp1;
		}
		// DE component
		if (fractal->transformCommon.functionEnabledDFalse)
		{
			if (fractal->transformCommon.functionEnabledBxFalse)
				distEst = aux->r_dz;
			else
				distEst = aux->DE;
			REAL temp5 = 0.0f;
			temp5 = distEst * fractal->foldColor.scaleD0;
			distEst = temp5;
		}
		// aux->color fold component
		if (fractal->transformCommon.functionEnabledAxFalse)
		{
			auxColor = aux->color;
			REAL temp8 = 0.0f;
			temp8 = auxColor * fractal->foldColor.scaleF0;
			auxColor = temp8;
		}
		// XYZ bias
		if (fractal->transformCommon.functionEnabledCxFalse)
		{
			REAL temp10 = 0.0f;
			REAL temp11 = 0.0f;
			REAL temp12 = 0.0f;
			temp10 = fabs(z.x) * fractal->transformCommon.additionConstantA000.x;
			temp11 = fabs(z.y) * fractal->transformCommon.additionConstantA000.y;
			temp12 = fabs(z.z) * fractal->transformCommon.additionConstantA000.z;
			XYZbias = temp10 + temp11 + temp12;
		}
		// plane bias
		if (fractal->transformCommon.functionEnabledAzFalse)
		{
			REAL temp16 = 0.0f;
			REAL temp17 = 0.0f;
			REAL temp18 = 0.0f;
			REAL4 tempP = fabs(z);
			temp16 = tempP.x * tempP.y * fractal->transformCommon.scale3D000.x;
			temp17 = tempP.y * tempP.z * fractal->transformCommon.scale3D000.y;
			temp18 = tempP.z * tempP.x * fractal->transformCommon.scale3D000.z;
			planeBias = temp16 + temp17 + temp18;
		}

		// build and scale componentMaster
		componentMaster = (fractal->foldColor.colorMin + R2 + distEst + auxColor + XYZbias + planeBias
												+ divideByIter + radius) // + factorR)nnnnnnnnnnnnnnnnnnnnnnn
											* fractal->foldColor.newScale0;
	}
	// divide by i
	if (fractal->transformCommon.functionEnabledCzFalse)
	{
		divideByIter =
			componentMaster * (1.0f + native_divide(fractal->transformCommon.scale, (aux->i + 1.0f)));
	}
	componentMaster += divideByIter;

	// non-linear palette options
	if (fractal->foldColor.parabEnabledFalse)
	{ // parabolic
		componentMaster += (componentMaster * componentMaster * fractal->foldColor.parabScale0);
	}
	if (fractal->foldColor.cosEnabledFalse)
	{ // trig
		REAL trig =
			128 * -fractal->foldColor.trigAdd1
			* (native_cos(componentMaster * 2.0f * native_divide(M_PI_F, fractal->foldColor.period1))
					- 1.0f);

		componentMaster += trig;
	}
	if (fractal->transformCommon.functionEnabledAyFalse)
	{ // log
		REAL logCurve = log(componentMaster + 1.0f) * fractal->foldColor.scaleE0;
		componentMaster += logCurve;
	}
	//	if (fractal->transformCommon.functionEnabledCyFalse &&
	//		aux->i >= fractal->transformCommon.startIterationsT
	//		&& aux->i < fractal->transformCommon.stopIterationsT) // hmmmmmmmmmmmmmm

	componentMaster *= 1.0f;
	// limit componentMaster
	if (componentMaster < fractal->foldColor.limitMin0)
		componentMaster = fractal->foldColor.limitMin0;
	if (componentMaster > fractal->foldColor.limitMax9999)
		componentMaster = fractal->foldColor.limitMax9999;

	// final component value + cumulative??
	aux->colorHybrid =
		(componentMaster * 256.0f) + (lastColorValue * fractal->transformCommon.scale0);

	// master controls color
	// aux->foldFactor = fractal->foldColor.compFold; // fold group weight

	// REAL scaleColor =
	//	 +  fabs(aux->actualScaleA);
	// scaleColor += fabs(fractal->mandelbox.scale);
	// aux->scaleFactor = scaleColor * fractal->foldColor.compScale;
	return z;
}