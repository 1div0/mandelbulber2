/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2017 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * RiemannBulbMsltoe Mod2
 * @reference
 * http://www.fractalforums.com/new-theories-and-research/
 * another-way-to-make-my-riemann-sphere-'bulb'-using-a-conformal-transformation/
 */

/* ### This file has been autogenerated. Remove this line, to prevent override. ### */

#ifndef DOUBLE_PRECISION
float4 RiemannBulbMsltoeMod2Iteration(float4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	Q_UNUSED(aux);

	float radius2 = fractal->transformCommon.minR05;
	float r2 = mad(z.z, z.z, mad(z.x, z.x, z.y * z.y)); // r2 or point radius squared
	if (r2 < radius2 * radius2)
	{
		if (fractal->transformCommon.functionEnabled)
			// smooth inside
			z *= radius2 * ((r2 * 0.1f) + 0.4f) * 1.18f
					 * native_divide(fractal->transformCommon.scaleA1, r2);
		else
		{
			z *= fractal->transformCommon.constantMultiplier111;
		}
	} // if internal smooth function disabled, then z = z * scale, default vect3(1f,1,1)
	else
	{
		// 1st scale variable, default vect3 (1.7f, 1.7f, 1.7f),
		z *= fractal->transformCommon.constantMultiplier222;
		float shift = fractal->transformCommon.offset1;
		// r1 = length^2,  //  + 1e-030f
		float r1 = mad(z.x, z.x, (z.y - shift) * (z.y - shift)) + z.z * z.z;
		// inversions by length^2
		z.x = native_divide(z.x, r1);
		z.y = native_divide((z.y - shift), r1);
		z.z = native_divide(z.z, r1);
		// 2nd scale variable , default = float (3.0f)
		z *= fractal->transformCommon.scale3;
		// y offset variable, default = float (1.9f);
		z.y = z.y + fractal->transformCommon.offset105;
		if (fractal->transformCommon.functionEnabledx)
		{
			z.x = z.x - round(z.x); // periodic cubic tiling,
			z.z = z.z - round(z.z);
		}
		if (fractal->transformCommon.functionEnabledxFalse)
		{
			z.x = fabs(native_sin(M_PI_F * z.x * fractal->transformCommon.scale1));
			z.z = fabs(native_sin(M_PI_F * z.z * fractal->transformCommon.scale1));
		}
	}
	return z;
}
#else
double4 RiemannBulbMsltoeMod2Iteration(
	double4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	Q_UNUSED(aux);

	double radius2 = fractal->transformCommon.minR05;
	double r2 = mad(z.z, z.z, mad(z.x, z.x, z.y * z.y)); // r2 or point radius squared
	if (r2 < radius2 * radius2)
	{
		if (fractal->transformCommon.functionEnabled)
			// smooth inside
			z *=
				radius2 * ((r2 * 0.1) + 0.4) * 1.18 * native_divide(fractal->transformCommon.scaleA1, r2);
		else
		{
			z *= fractal->transformCommon.constantMultiplier111;
		}
	} // if internal smooth function disabled, then z = z * scale, default vect3(1,1,1)
	else
	{
		// 1st scale variable, default vect3 (1.7, 1.7, 1.7),
		z *= fractal->transformCommon.constantMultiplier222;
		double shift = fractal->transformCommon.offset1;
		// r1 = length^2,  //  + 1e-061
		double r1 = mad(z.x, z.x, (z.y - shift) * (z.y - shift)) + z.z * z.z;
		// inversions by length^2
		z.x = native_divide(z.x, r1);
		z.y = native_divide((z.y - shift), r1);
		z.z = native_divide(z.z, r1);
		// 2nd scale variable , default = double (3.0)
		z *= fractal->transformCommon.scale3;
		// y offset variable, default = double (1.9);
		z.y = z.y + fractal->transformCommon.offset105;
		if (fractal->transformCommon.functionEnabledx)
		{
			z.x = z.x - round(z.x); // periodic cubic tiling,
			z.z = z.z - round(z.z);
		}
		if (fractal->transformCommon.functionEnabledxFalse)
		{
			z.x = fabs(native_sin(M_PI * z.x * fractal->transformCommon.scale1));
			z.z = fabs(native_sin(M_PI * z.z * fractal->transformCommon.scale1));
		}
	}
	return z;
}
#endif
