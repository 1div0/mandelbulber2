/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2017 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * Add exp2(z)
 */

/* ### This file has been autogenerated. Remove this line, to prevent override. ### */

#ifndef DOUBLE_PRECISION
float4 TransfAddExp2ZIteration(float4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	float4 tempZ = z;

	if (fractal->transformCommon.functionEnabledx)
	{
		if (fractal->transformCommon.functionEnabledAx)
		{
			tempZ.x = fabs(z.x);
			tempZ.x = native_exp2(tempZ.x * -fractal->transformCommon.constantMultiplier000.x) - 1.0;
			//z.x += sign(z.x) * tempZ.x;
			z.x -= copysign(tempZ.x, z.x);
		}
		else if (fractal->transformCommon.functionEnabledAxFalse)
		{
			tempZ.x = fabs(z.x);
			tempZ.x = native_exp2(tempZ.x * -fractal->transformCommon.constantMultiplier000.x) - 1.0;
			//z.x -= sign(z.x) * tempZ.x;
			z.x += copysign(tempZ.x, z.x);
		}
		else // no fabs
			z.x += native_exp2(tempZ.x * fractal->transformCommon.constantMultiplier000.x) - 1.0;
	}

	/*{
		if ( != fractal->transformCommon.functionEnabledAx && != fractal->transformCommon.functionEnabledAxFalse)
		{
				z.x += native_exp2(tempZ.x * fractal->transformCommon.constantMultiplier000.x) - 1.0;
		}
		else
		{
		tempZ.x = fabs(z.x);
		tempZ.x = native_exp2(tempZ.x * -fractal->transformCommon.constantMultiplier000.x) - 1.0;
		if (fractal->transformCommon.functionEnabledAx)
		{
			//z.x += sign(z.x) * tempZ.x;
			z.x -= copysign(tempZ.x, z.x);
		}
		else
		{
			//z.x -= sign(z.x) * tempZ.x;
			z.x += copysign(tempZ.x, z.x);
		}
	}*/



	if (fractal->transformCommon.functionEnabledy)
	{
		if (fractal->transformCommon.functionEnabledAy)
		{
			tempZ.y = fabs(z.y);
			tempZ.y = native_exp2(tempZ.y * -fractal->transformCommon.constantMultiplier000.y) - 1.0;
			//z.y += sign(z.y) * tempZ.y;
			z.y -= copysign(tempZ.y, z.y);
		}
		else if (fractal->transformCommon.functionEnabledAyFalse)
		{
			tempZ.y = fabs(z.y);
			tempZ.y = native_exp2(tempZ.y * -fractal->transformCommon.constantMultiplier000.y) - 1.0;
			//z.y -= sign(z.y) * tempZ.y;
			z.y += copysign(tempZ.y, z.y);
		}
		else
			z.y += native_exp2(tempZ.y * fractal->transformCommon.constantMultiplier000.y) - 1.0;
	}

	if (fractal->transformCommon.functionEnabledz)
	{
		if (fractal->transformCommon.functionEnabledAz)
		{
			tempZ.z = fabs(z.z);
			tempZ.z = native_exp2(tempZ.z * -fractal->transformCommon.constantMultiplier000.z) - 1.0;
			//z.z += sign(z.z) * tempZ.z;
			z.z -= copysign(tempZ.z, z.z);
		}
		else if (fractal->transformCommon.functionEnabledAzFalse)
		{
			tempZ.z = fabs(z.z);
			tempZ.z = native_exp2(tempZ.z * -fractal->transformCommon.constantMultiplier000.z) - 1.0;
			//z.z -= sign(z.z) * tempZ.z;
			z.z += copysign(tempZ.z, z.z);
		}
		else
			z.z += native_exp2(tempZ.z * fractal->transformCommon.constantMultiplier000.z) - 1.0;
	}

	//vector z version
	if (fractal->transformCommon.functionEnabledBzFalse)
	{		float4 tempS;
		if (fractal->transformCommon.functionEnabled)
		{
			tempS = fabs(z);
			float4 tempT = tempS * -fractal->transformCommon.scale0;
			tempS.x = native_exp2(tempT.x) - 1.0;
			tempS.y = native_exp2(tempT.y) - 1.0;
			tempS.z = native_exp2(tempT.z) - 1.0;

			z.x -= copysign(tempS.x, z.x);
			z.y -= copysign(tempS.y, z.y);
			z.z -= copysign(tempS.z, z.z);
			//z.x += sign(z.x) * tempS.x;
			//z.y += sign(z.y) * tempS.y;
			//z.z += sign(z.z) * tempS.z;
		}
		else if (fractal->transformCommon.functionEnabledFalse)
		{
			tempS = fabs(z);
			float4 tempT = tempS * -fractal->transformCommon.scale0;
			tempS.x = native_exp2(tempT.x) - 1.0;
			tempS.y = native_exp2(tempT.y) - 1.0;
			tempS.z = native_exp2(tempT.z) - 1.0;

			z.x += copysign(tempS.x, z.x);
			z.y += copysign(tempS.y, z.y);
			z.z += copysign(tempS.z, z.z);
			//z.x -= sign(z.x) * tempS.x;
			//z.y -= sign(z.y) * tempS.y;
			//z.z -= sign(z.z) * tempS.z;
		}
		else
		{
			float4 tempR = z * fractal->transformCommon.scale0;
			z.x += native_exp2(tempR.x) - 1.0;
			z.y += native_exp2(tempR.y) - 1.0;
			z.z += native_exp2(tempR.z) - 1.0;
		}
	}

	aux->DE *= fractal->analyticDE.scale1; // DE tweak
	return z;
}
#else
double4 TransfAddExp2ZIteration(double4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	double4 tempZ = z;

	if (fractal->transformCommon.functionEnabledx)
	{
		if (fractal->transformCommon.functionEnabledAx)
		{
			tempZ.x = fabs(z.x);
			tempZ.x = native_exp2(tempZ.x * -fractal->transformCommon.constantMultiplier000.x) - 1.0;
			z.x -= copysign(tempZ.x, z.x);
		}
		else if (fractal->transformCommon.functionEnabledAxFalse)
		{
			tempZ.x = fabs(z.x);
			tempZ.x = native_exp2(tempZ.x * -fractal->transformCommon.constantMultiplier000.x) - 1.0;
			z.x += copysign(tempZ.x, z.x);
		}
		else // no fabs
			z.x += native_exp2(tempZ.x * fractal->transformCommon.constantMultiplier000.x) - 1.0;
	}

	if (fractal->transformCommon.functionEnabledy)
	{
		if (fractal->transformCommon.functionEnabledAy)
		{
			tempZ.y = fabs(z.y);
			tempZ.y = native_exp2(tempZ.y * -fractal->transformCommon.constantMultiplier000.y) - 1.0;
			z.y -= copysign(tempZ.y, z.y);
		}
		else if (fractal->transformCommon.functionEnabledAyFalse)
		{
			tempZ.y = fabs(z.y);
			tempZ.y = native_exp2(tempZ.y * -fractal->transformCommon.constantMultiplier000.y) - 1.0;
			z.y += copysign(tempZ.y, z.y);
		}
		else
			z.y += native_exp2(tempZ.y * fractal->transformCommon.constantMultiplier000.y) - 1.0;
	}

	if (fractal->transformCommon.functionEnabledz)
	{
		if (fractal->transformCommon.functionEnabledAz)
		{
			tempZ.z = fabs(z.z);
			tempZ.z = native_exp2(tempZ.z * -fractal->transformCommon.constantMultiplier000.z) - 1.0;
			z.z -= copysign(tempZ.z, z.z);
		}
		else if (fractal->transformCommon.functionEnabledAzFalse)
		{
			tempZ.z = fabs(z.z);
			tempZ.z = native_exp2(tempZ.z * -fractal->transformCommon.constantMultiplier000.z) - 1.0;
			z.z += copysign(tempZ.z, z.z);
		}
		else
			z.z += native_exp2(tempZ.z * fractal->transformCommon.constantMultiplier000.z) - 1.0;
	}

	//vector z version
	if (fractal->transformCommon.functionEnabledBzFalse)
	{		double4 tempS;
		if (fractal->transformCommon.functionEnabled)
		{
			tempS = fabs(z);
			double4 tempT = tempS * -fractal->transformCommon.scale0;
			tempS.x = native_exp2(tempT.x) - 1.0;
			tempS.y = native_exp2(tempT.y) - 1.0;
			tempS.z = native_exp2(tempT.z) - 1.0;

			z.x -= copysign(tempS.x, z.x);
			z.y -= copysign(tempS.y, z.y);
			z.z -= copysign(tempS.z, z.z);
		}
		else if (fractal->transformCommon.functionEnabledFalse)
		{
			tempS = fabs(z);
			double4 tempT = tempS * -fractal->transformCommon.scale0;
			tempS.x = native_exp2(tempT.x) - 1.0;
			tempS.y = native_exp2(tempT.y) - 1.0;
			tempS.z = native_exp2(tempT.z) - 1.0;

			z.x += copysign(tempS.x, z.x);
			z.y += copysign(tempS.y, z.y);
			z.z += copysign(tempS.z, z.z);
		}
		else
		{
			double4 tempR = z * fractal->transformCommon.scale0;
			z.x += native_exp2(tempR.x) - 1.0;
			z.y += native_exp2(tempR.y) - 1.0;
			z.z += native_exp2(tempR.z) - 1.0;
		}
	}
	aux->DE *= fractal->analyticDE.scale1; // DE tweak
	return z;
}
#endif
