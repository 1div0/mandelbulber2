/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2017 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * Parabolic Fold by mclarekin
 */

/* ### This file has been autogenerated. Remove this line, to prevent override. ### */

#ifndef DOUBLE_PRECISION
float4 TransfParabFoldIteration(float4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	float4 temp = z;

	float4 slope2 = fractal->transformCommon.constantMultiplier111;
	float4 lengthAdd = fractal->transformCommon.additionConstant000;
	float4 factorP;

	factorP.x = native_divide(-slope2.x, (lengthAdd.x * 2.0f));
	factorP.y = native_divide(-slope2.y, (lengthAdd.y * 2.0f));
	factorP.z = native_divide(-slope2.z, (lengthAdd.z * 2.0f));

	if (temp.x > 0)
	{
		if (temp.x < lengthAdd.x)
		{
			z.x = z.x * z.x * factorP.x;
		}
		else
		{
			z.x = (z.x - native_divide(lengthAdd.x, 2.0f)) * slope2.x;
		}
	}
	if (temp.y > 0)
	{
		if (temp.y < lengthAdd.y)
		{
			z.y = z.y * z.y * factorP.y;
		}
		else
		{
			z.y = (z.y - native_divide(lengthAdd.y, 2.0f)) * slope2.y;
		}
	}
	if (temp.z > 0)
	{
		if (temp.z < lengthAdd.z)
		{
			z.z = z.z * z.z * factorP.z;
		}
		else
		{
			z.z = (z.z - native_divide(lengthAdd.z, 2.0f)) * slope2.z;
		}
	}

	if (temp.x < 0)
	{
		if (temp.x > -lengthAdd.x)
		{
			z.x = z.x * z.x * -factorP.x;
		}
		else
		{
			z.x = (z.x + native_divide(lengthAdd.x, 2.0f)) * slope2.x;
		}
	}
	if (temp.y < 0)
	{
		if (temp.y > -lengthAdd.y)
		{
			z.y = z.y * z.y * -factorP.y;
		}
		else
		{
			z.y = (z.y + native_divide(lengthAdd.y, 2.0f)) * slope2.y;
		}
	}

	if (temp.z < 0)
	{

		if (temp.z > -lengthAdd.z)
		{
			z.z = z.z * z.z * -factorP.z;
		}
		else
		{
			z.z = (z.z + native_divide(lengthAdd.z, 2.0f)) * slope2.z;
		}
	}

	// z.x = copysign(z.x, temp.x);
	// z.y = copysign(z.y, temp.y);
	// z.z = copysign(z.z, temp.z);

	if (fractal->transformCommon.functionEnabledxFalse)
	{
		z = (z - temp) * fractal->transformCommon.scale3D111;
	}
	if (fractal->transformCommon.functionEnabledyFalse)
	{
		z = (z - temp) * temp * fractal->transformCommon.scale3D111;

		z.x = copysign(z.x, temp.x);
		z.y = copysign(z.y, temp.y);
		z.z = copysign(z.z, temp.z);
	}
	if (fractal->transformCommon.functionEnabledzFalse)
	{
		z = (z - temp) * temp * fractal->transformCommon.scale3D111;
	}

	if (fractal->transformCommon.functionEnabledFalse)
	{
		float tempL = length(temp);
		// if (tempL < 1e-21f) tempL = 1e-21f;
		float avgScale = native_divide(length(z), tempL);
		aux->r_dz *= avgScale;
		aux->DE = aux->DE * avgScale;
	}
	aux->DE = mad(aux->DE, fractal->analyticDE.scale1, fractal->analyticDE.offset0);
	return z;
}
#else
double4 TransfParabFoldIteration(double4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	double4 temp = z;

	double4 slope2 = fractal->transformCommon.constantMultiplier111;
	double4 lengthAdd = fractal->transformCommon.additionConstant000;
	double4 factorP;

	factorP.x = native_divide(-slope2.x, (lengthAdd.x * 2.0));
	factorP.y = native_divide(-slope2.y, (lengthAdd.y * 2.0));
	factorP.z = native_divide(-slope2.z, (lengthAdd.z * 2.0));

	if (temp.x > 0)
	{
		if (temp.x < lengthAdd.x)
		{
			z.x = z.x * z.x * factorP.x;
		}
		else
		{
			z.x = (z.x - lengthAdd.x / 2.0) * slope2.x;
		}
	}
	if (temp.y > 0)
	{
		if (temp.y < lengthAdd.y)
		{
			z.y = z.y * z.y * factorP.y;
		}
		else
		{
			z.y = (z.y - lengthAdd.y / 2.0) * slope2.y;
		}
	}
	if (temp.z > 0)
	{
		if (temp.z < lengthAdd.z)
		{
			z.z = z.z * z.z * factorP.z;
		}
		else
		{
			z.z = (z.z - lengthAdd.z / 2.0) * slope2.z;
		}
	}

	if (temp.x < 0)
	{
		if (temp.x > -lengthAdd.x)
		{
			z.x = z.x * z.x * -factorP.x;
		}
		else
		{
			z.x = (z.x + lengthAdd.x / 2.0) * slope2.x;
		}
	}
	if (temp.y < 0)
	{
		if (temp.y > -lengthAdd.y)
		{
			z.y = z.y * z.y * -factorP.y;
		}
		else
		{
			z.y = (z.y + lengthAdd.y / 2.0) * slope2.y;
		}
	}

	if (temp.z < 0)
	{

		if (temp.z > -lengthAdd.z)
		{
			z.z = z.z * z.z * -factorP.z;
		}
		else
		{
			z.z = (z.z + lengthAdd.z / 2.0) * slope2.z;
		}
	}

	// z.x = copysign(z.x, temp.x);
	// z.y = copysign(z.y, temp.y);
	// z.z = copysign(z.z, temp.z);

	if (fractal->transformCommon.functionEnabledxFalse)
	{
		z = (z - temp) * fractal->transformCommon.scale3D111;
	}
	if (fractal->transformCommon.functionEnabledyFalse)
	{
		z = (z - temp) * temp * fractal->transformCommon.scale3D111;

		z.x = copysign(z.x, temp.x);
		z.y = copysign(z.y, temp.y);
		z.z = copysign(z.z, temp.z);
	}
	if (fractal->transformCommon.functionEnabledzFalse)
	{
		z = (z - temp) * temp * fractal->transformCommon.scale3D111;
	}

	if (fractal->transformCommon.functionEnabledFalse)
	{
		double tempL = length(temp);
		// if (tempL < 1e-21) tempL = 1e-21;
		double avgScale = native_divide(length(z), tempL);
		aux->r_dz *= avgScale;
		aux->DE = aux->DE * avgScale;
	}
	aux->DE = mad(aux->DE, fractal->analyticDE.scale1, fractal->analyticDE.offset0);
	return z;
}
#endif
